# Hooks

Hooks allow you to interact with a pre-defined task and alter its behaviors by injecting **hook functions** (also called **hook plugins**) into it.

<!-- TOC -->

- [Introduction](#introduction)
  - [Hook's Scopes](#hooks-scopes)
  - [Hook's Types](#hooks-types)
- [Working with Global Hooks](#working-with-global-hooks)
- [Hook function signature](#hook-function-signature)
  - [Global Scoped Hook Drawback](#global-scoped-hook-drawback)
- [Working with Local Scoped Hooks](#working-with-local-scoped-hooks)
  - [Inside a task function](#inside-a-task-function)
  - [Injecting hook functions](#injecting-hook-functions)
- [Custom Accumulators](#custom-accumulators)
- [Interact with hooks](#interact-with-hooks)
- [Known Issues](#known-issues)
  - [Non Completing Tasks](#non-completing-tasks)

<!-- /TOC -->

## Introduction

Hooks can be categorized by **scope** and **type**.

### Hook's Scopes

The scope of a hook defines how injected functions interact with the build process. If a hook's scope is **global**, injected functions will affect every task that executes that hook.

If a hook's scope is **local** then injecting a function into a task will affect only that task's instance.

### Hook's Types

A hook acts essentially as a reducer that receives an input value (called **accumulator**), transforms it and then outputs the transformed value. An accumulator could be any JavaScript value, but the most common are:

- [Lazypipe](https://github.com/OverZealous/lazypipe). This is the default type.
- [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
- [Map][1]/[Set][2]/[Array][3].

[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
[2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
[3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

## Working with Global Hooks

The main configuration object generated by `@wok-cli/core` exposes a global scoped hook object called `globalHooks` that you can leverage inside your tasks to interact with them at runtime:

Let's say we have a `scripts` task that just copies files from one folder to another:

```js
// tasks/scripts.js

module.exports = function scriptsTask(gulp, params, env, api) {
  return function scripts() {
    return gulp.src(params.src).pipe(gulp.dest(params.dest));
  };
};
```

And we use it like this:

```js
// gulpfile.js
const $ = require('@wok-cli/core');
const scriptsTask = require('./tasks/scripts.js');

const scripts = $.task(scriptsTask, {
  src: 'src/**',
  dest: 'public',
});

exports.scripts = scripts;
```

To be able to leverage hooks, we must define where to call them inside the task:

```diff
// tasks/scripts.js

module.exports = function scriptsTask(gulp, params, env, api) {
  return function scripts() {
    return gulp
      .src(params.src)
+     .pipe(api.globalHooks.call('scripts'))
      .pipe(gulp.dest(params.dest));
  };
};
```

We can then inject a hook function in `gulpfile.js` using the `.tap()` method. For example let's run the code through a minifier plugin like [gulp-terser](https://www.npmjs.com/package/gulp-terser):

```diff
// gulpfile.js
const $ = require('@wok-cli/core');
const scriptsTask = require('./tasks/scripts.js');

const scripts = $.task(scriptsTask, {
  src: 'src/**',
  dest: 'public',
});

+ function minify(lazypipe) {
+   return lazypipe.pipe(require('gulp-terser'));
+ }

+ $.api.globalHooks.tap('scripts', 'minify', minify);

exports.scripts = scripts;
```

## Hook function signature

The `.tap()` third argument is called **hook function** (or **hook plugin**). It receives the following arguments:

- an accumulator object (defaults to a [lazypipe](https://github.com/OverZealous/lazypipe) stream)
- the value of `$.env`
- the value of `$.api`
- any other argument passed to `.call()` after the hook name.

This lets you, for example, programmatically add or remove a gulp plugin based on the current environment:

```js
// minify the source just on production
function minify(lazypipe, env) {
  if (env.production !== true) {
    return lazypipe;
  }
  return lazypipe.pipe(require('gulp-terser'));
}

$.api.globalHooks.tap('scripts', 'minify', minify);
```

!> **Important**: Consecutive hook functions will receive the accumulator object returned from the previous one. Always remember to return the accumulator inside a hook function!

?> Wok provides an utility function to streamline hook function definition. See [here](https://dwightjack.github.io/wok-pkgs/#/packages/core/create-tasks?id=task-plugins) for details.

### Global Scoped Hook Drawback

Since global scoped hooks are shared among all tasks, different instances of the same task will share the same hook function.

For example let's add a new script task for the `vendors` folder:

```js
// gulpfile.js
const $ = require('@wok-cli/core');
const scriptsTask = require('./tasks/scripts.js');

const scripts = $.task(scriptsTask, {
  src: 'src/**',
  dest: 'public',
});

const vendorsScripts = $.task(scriptsTask, {
  src: 'vendors/**',
  dest: 'public/vendors',
});

function minify(lazypipe) {
  return lazypipe.pipe(require('gulp-terser'));
}

$.api.globalHooks.tap('scripts', 'minify', minify);

exports.scripts = scripts;
exports.vendors = vendorsScripts;
```

Because both `scripts` and `vendorsScripts` share the global `scripts` hook, terser will be executed on both tasks, which sometimes could not be what you really want.

## Working with Local Scoped Hooks

Local scoped hooks are bound to each single task instance created by the `$.task` function.

### Inside a task function

Inside the task function call `this.getHooks()` to retrieve the local hooks object:

```diff
// tasks/scripts.js

module.exports = function scriptsTask(gulp, params, env, api) {

+ const $hooks = this.getHooks();

  return function scripts() {
    return gulp
      .src(params.src)
-     .pipe(api.globalHooks.call('scripts'))
+     .pipe($hooks.call('default'))
      .pipe(gulp.dest(params.dest));
  };
};
```

!> **Note**: since arrow functions [don't have their own `this`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_separate_this), you need to stick to the `function` statement to retrieve the local hooks API with `this.getHooks()`.

### Injecting hook functions

To inject a hook function into a task call its `.tap()` method:

```diff
// gulpfile.js
// ...

const scripts = $.task(scriptsTask, {
  src: 'src/**',
  dest: 'public',
});

function minify(lazypipe) {
  return lazypipe.pipe(require('gulp-terser'));
}

- $.api.globalHooks.tap('scripts', 'minify', minify);
+ scripts.tap('default', 'minify', minify);

exports.scripts = scripts;
```

?> **Tip** You can access the complete hooks api of the task from `scripts.$hooks`.

## Custom Accumulators

By default hooks accumulators are [lazypipe](https://github.com/OverZealous/lazypipe) streams. Anyway you can define your own accumulator by calling `.callWith()` instead of `.call()` and passing your custom value as second argument:

```js
const { globalHooks } = $.api;

globalHooks.tap('value', 'multiply', (num) => num * 2);

const number = globalHooks.callWith('value', 10);

// number === 20
```

## Interact with hooks

Each hook object lets you finely interact with registered hook functions. You can, for example, remove any previously injected function with the `delete()` method:

```js
// remove the minify hook function
$.api.globalHooks.delete('scripts', 'minify');

// remove any function registered for the scripts hook
$.api.globalHooks.delete('scripts');
```

Refer to the [`Hook` class API](packages/core/api/lib/hooks) for further details.

## Known Issues

### Non Completing Tasks

If you call a hook as the last step of a task's stream that task [might not complete correctly](https://stackoverflow.com/questions/40098156/what-about-this-combination-of-gulp-concat-and-lazypipe-is-causing-an-error-usin/40101404#40101404).

For example take this copy task:

```js
function copyTask(gulp) {
  const $hooks = this.getHooks();

  return function copy() {
    gulp
      .src('src/**')
      .pipe(gulp.dest('public'))
      .pipe($hooks.call('complete'));
    // ^-- this will not complete
  };
}
```

In order to make it work you need to add an empty stream after the hook. You can use the `noopStream` utility function provided by `@wok-cli/core`:

```diff
+ const { noopStream } = require('@wok-cli/core');

function copyTask(gulp) {
  const $hooks = this.getHooks();

  return function copy() {
    gulp
      .src('src/**')
      .pipe(gulp.dest('public'))
      .pipe($hooks.call('complete'))
+     .pipe(noopStream());
  };
}
```
